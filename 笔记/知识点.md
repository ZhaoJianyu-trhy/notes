**主要记录一些面试题，面经上面的一些零碎知识点**

------

### 线程池的状态

从线程池源码，可以看出定义了5个状态

```java
    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;
	
    private static final int COUNT_BITS = Integer.SIZE - 3;
    //Integer.SIZE位于Integer类中，其实就是int类型的位数，32
    @Native public static final int SIZE = 32;
```

<img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/20180514165513759" alt="img"  />

**RUNNING：**

状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 

状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

**SHUTDOWN**：

状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。

状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。

**STOP**

状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 

状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

**TIDYING**

状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 

状态切换：

当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。 
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

**TERMINATED**

状态说明：线程池彻底终止，就变成TERMINATED状态。 

状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

------

### 线程池拒绝策略

<img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/1521946099154-17b29e18-6853-4b39-8e2a-007ea89387bd.png" alt="undefined" style="zoom:80%;" />

| 拒绝策略            | 拒绝行为                                               |
| ------------------- | ------------------------------------------------------ |
| AbortPolicy         | 抛出RejectedExecutionException                         |
| DiscardPolicy       | 什么也不做，直接忽略                                   |
| DiscardOldestPolicy | 丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置 |
| CallerRunsPolicy    | 直接由提交任务者执行这个任务                           |

线程池默认的拒绝行为是`AbortPolicy`，也就是抛出`RejectedExecutionHandler`异常，该异常是非受检异常，很容易忘记捕获。如果不关心任务被拒绝的事件，可以将拒绝策略设置成`DiscardPolicy`，这样多余的任务会悄悄的被忽略。

------

### Java线程的状态

查看Thread源码，发现有如下状态

```java
public enum State {
    
        NEW,
    
        RUNNABLE,
    
        BLOCKED,

        WAITING,

        TIMED_WAITING,

        TERMINATED;
    }
```

**新建（New）：**创建后尚未启动的线程处于这种状态

**运行（Runnable）：**包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可
能正在执行，也有可能正在等待着操作系统为它分配执行时间

**无限期等待（Waiting）：**处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线
程显式唤醒。以下方法会让线程陷入无限期的等待状态：

- 没有设置Timeout参数的Object::wait()方法
- 没有设置Timeout参数的Thread::join()方法
- LockSupport::park()方法

**·限期等待（Timed Waiting）：**处于这种状态的线程也不会被分配处理器执行时间，不过无须等待
被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状
态：

- Thread::sleep()方法；
- 设置了Timeout参数的Object::wait()方法；
- 设置了Timeout参数的Thread::join()方法；
- LockSupport::parkNanos()方法；
- LockSupport::parkUntil()方法。

**·阻塞（Blocked）：**线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到
一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时
间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。

**结束（Terminated）：**已终止线程的线程状态，线程已经结束执行



![image-20210514184924691](%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210514184924691.png)

------

### 进程状态

![进程状态](%E7%9F%A5%E8%AF%86%E7%82%B9.assets/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png)

------

### jvm对象何时进入老年代

1. 躲过15次GC之后进入老年代

2. 动态对象年龄判断

   假如说当前放对象的Survivor区域里，一批对象的总大小大于了这块Survivor区域的内存大小的50%，那么此时大于等于这批对象年龄的对象，就可以直接进入老年代了。

3. 大对象直接进入老年代

   有一个JVM参数，就是“-XX:PretenureSizeThreshold”，可以把它的值设置为字节数，比如“1048576”字节，就是1MB，意思就是如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年代里去，压根不会经过年轻代。之所以这么做，是因为要避免年轻代里出现那种大对象，然后屡次躲过GC，还得把他在两个Survivor区域里来回复制多次之后才能进入老年代

4. 标记复制算法，担保策略，即剩余的对象总大小超过了1个survivor大小，且老年代放的下，进入老年代

------

### 何时 full gc

在**执行任何一次Minor GC之前，JVM都会先检查一些老年代可用的内存空间，是否大于年轻代所有对象的总大小**，为什么呢？因为最极端的情况下，可能年轻代Minor GC之后，所有对象都存活下来了，那岂不是年轻代所有对象全部进入老年代

如果说发现老年代内存大小是大于年轻代所有对象的，此时就可以放心大胆地对年轻代发起一次Minor GC了。

**假如Minor GC之前，发现老年代的可用内存已经小于了年轻代的全部对象大小，就会看一个“-XX:-HandlePromotionFailure”的参数是否设置了**

**如果有这个参数，那么就会看看老年代的内存大小，是否大于之前每一次Minor GC后进去老年代对象的平均大小**

==如果上面步骤判断失败了，或者是“-XX:-HandlePromotionFailure”参数没设置，此时就会直接触发一次“Full GC”==

如果上面两个步骤判断成功，那么就可以尝试Minor GC，此时进行Minor GC有几种可能：

1. Minor GC过后，剩余的存活对象的大小，小于Survivor区的大小，那么此时存活对象进入Survivor区即可
2. Minor GC过后，剩余的存活对象的大小，大于Survivor区的大小，但是小于老年代可用内存大小，就直接进入老年代即可
3. ==Minor GC过后，剩余的存活对象的大小，大于Survivor区的大小，同时大于老年代可用内存大小，此时就会发生“Handle Promotion Failure”的情况，这个时候就会出发一次“Full GC”==

如果Full GC之后，老年代还是没有足够空间存放Minor GC过后的剩余存活对象，此时就会导致所谓的“**OOM”内存溢出**了

==System.gc()建议full gc，但不一定真的就full gc了==

在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照(STAB)算法来实现的。G1为每个Region设计了两个名为TAMS(Top at Mark Start)的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。如果内存回收的速度赶不上内存分配二等速度，==G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”==。

------

### HTTP

HTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，服务器怎样将文档传送给浏览器

<img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210515174344250.png" alt="image-20210515174344250" style="zoom:80%;" />

**POST和GET的区别**

1. GET提交的数据放在URL中，POST则不会。这是最显而易见的差别。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密）
2. GET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源）
3. GET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有
4. GET可以被保存为书签，POST不可以。这一点也能感受到。
5. GET能被缓存，POST不能
6. GET只允许ASCII字符，POST没有限制
7. GET会保存再浏览器历史记录中，POST不会。这点也能感受到。

总之，两者之间没有本质区别，区别就在于数据存储的位置。各自有适用环境，根据需求选择合适的方法即可。

------

### DNS域名系统

属于应用层，核心功能是将域名解析成IP地址，使用UDP报文（减少开销）

域名服务器程序在专设的节点上运行，运行的机器称为域名服务器

<img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210514214843661.png" alt="image-20210514214843661" style="zoom:80%;" />

<img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210514214902069.png" alt="image-20210514214902069" style="zoom:80%;" />

**根域名服务器**：最重要的域名服务器，也是最高层次的，知道所有的顶级域名服务器域名和IP地址；不管哪一个本地域名服务器，只要自己无法解析域名，就要去查询根域名服务器

**顶级域名服务器**：负责管理在该顶级域名服务器注册的所有二级域名

**权限域名服务器**：负责一个区的域名服务器

**本地域名服务器**：并不属于上述层次的服务器；当一个主机发送DNS查询请求时，这个查询报文就发送给本地域名服务器；为了提高可靠性，可以采用主从复制

主机向本地域名服务器的查询采用**递归查询**：如果本地域名服务器无法解析，那么本地域名服务器就以DNS客户的身份，去根域名服务器查询

本地域名服务器像根域名服务器查询是**迭代查询**：根域名服务器向本地域名服务器返回IP地址或者顶级域名服务器IP地址，如果没有查询到则根域名服务器向顶级域名服务器查询；顶级域名服务器返回IP地址或者权限域名服务器IP地址；最终查询到了IP地址返回给主机

<img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210514215903924.png" alt="image-20210514215903924" style="zoom:80%;" />

**缓存（输入一个url的过程中可以说到）**

主机可以缓存本地域名服务器已有的数据

本地域名服务器可以缓存对应的IP地址、或者顶级域名服务器（查询不会经过根域名服务器，直接查询缓存的顶级域名服务器）

------

### 输入url，进行了什么工作

1. 浏览器分析链接指向页面的URL
2. 浏览器向DNS请求解析域名的IP地址
3. 域名服务器解析出IP地址ip（缓存，本地域名服务器—>根域名服务器—>顶级域名服务器—>权限域名服务器）
4. 浏览器先和代理服务器建立TCP连接，向代理服务器发出HTTP请求报文
5. 若代理服务器已经存放了请求的对象，放入HTTP响应报文中返回给PC的浏览器
6. 否则，代理服务器代表PC浏览器，与查询的服务器建立TCP连接，发出HTTP请求报文
7. 服务器将请求的对象放入HTTP响应报文返回给代理服务器
8. 代理服务器收到对象后，先复制到本地存储器中，然后再将对象放入HTTP响应报文中，通过已建立的TCP连接，返回给PC的浏览器
9. 由浏览器渲染生成网页

看这个博客：[在浏览器中输入URL地址到返回页面发生了什么 - WJiaHao's Blog (goldendream.top)](https://www.goldendream.top/archives/zai-liu-lan-qi-zhong-shu-ru-url-de-zhi-dao-fan-hui-ye-mian-fa-shen-me-shen-me)

------

### 网络7层、4层、5层模型

<img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210515100934149.png" alt="image-20210515100934149" style="zoom:80%;" />

------

### POST和GET的区别

1. GET提交的数据放在URL中，POST则不会。这是最显而易见的差别。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密）
2. GET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源）
3. GET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有
4. GET可以被保存为书签，POST不可以。这一点也能感受到。
5. GET能被缓存，POST不能
6. GET只允许ASCII字符，POST没有限制
7. GET会保存再浏览器历史记录中，POST不会。这点也能感受到。

总之，两者之间没有本质区别，区别就在于数据存储的位置。各自有适用环境，根据需求选择合适的方法即可。

------

### map红黑树为啥阈值是8？

jdk源码中有英文注释

```java
* usages with well-distributed user hashCodes, tree bins are
* rarely used.  Ideally, under random hashCodes, the frequency of
* nodes in bins follows a Poisson distribution
* (http://en.wikipedia.org/wiki/Poisson_distribution) with a
* parameter of about 0.5 on average for the default resizing
* threshold of 0.75, although with a large variance because of
* resizing granularity. Ignoring variance, the expected
* occurrences of list size k are (exp(-0.5) * pow(0.5, k) /
* factorial(k)). The first values are:
*
* 0:    0.60653066
* 1:    0.30326533
* 2:    0.07581633
* 3:    0.01263606
* 4:    0.00157952
* 5:    0.00015795
* 6:    0.00001316
* 7:    0.00000094
* 8:    0.00000006
* more: less than 1 in ten million
```

大概意思就是：如果 hashCode的分布离散良好的话，那么红黑树是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，注释中给我们展示了1-8长度的具体命中概率，当长度为8的时候，概率概率仅为0.00000006，这么小的概率，HashMap的红黑树转换几乎不会发生

当然，这是理想的算法，但不妨某些用户使用HashMap过程导致hashCode分布离散很差的场景，这个时候再转换为红黑树就是一种很好的退让策略。

------

### 负载因子为什么是0.75

默认负载因子为0.75的时候在时间和空间成本上提供了很好的折中。太高了可以减少空间开销，但是会增加查找复杂度，反之亦然

------

### 为什么退化为链表的阈值是6

主要是一个过渡，避免链表和红黑树之间频繁的转换。如果阈值是7的话，删除一个元素红黑树就必须退化为链表，增加一个元素就必须树化，来回不断的转换结构无疑会降低性能，所以阈值才不设置的那么临界。

------

### TCP和UDP能不能共用一个端口，为什么？

端口这个概念是由操作系统划分的。因为内核不可能把所有网络数据都发送给所有的进程，所以为了区分哪些数据该划分给哪些进程，便在传输层的协议中定义了端口。而tcp和udp协议中的端口号占位都是16位，所以操作系统能绑定的端口也就只有65535个。这也解释了为什么linux里设置单个进程所能打开的最大文件描述符数量最好设置为65535

端口可以形象地比喻成操作系统上的编号唯一的文件，应用程序和网络协议可以对其进行i/o操作

**linux是以协议、ip、端口来绑定端口的，所以不同协议相同的ip和端口也是可以绑定成功的。**

------

### cookie、session、localStorage，sessionStorage

**Cookie**

cookie是为了解决HHTP无状态特性问题的

工作流程：用户A浏览使用cookie的网站时，网站的服务器为A生成一个唯一的识别码，并以此为索引在服务器后端数据库中产生一个项目，再给A的HTTP响应报文中添加一个Set-cookie的首部行，字段为“Set-cookie”，值为识别码，例如`Set-cookie 123456`

A收到响应后，其浏览器在它管理的特定cookie文件中添加一行，包括服务器的主机名和Set-cookie后面给出的识别码；A继续浏览这个网站时，每发送一个HTTP请求报文，其浏览器就会从其cookie文件中取出这个识别码，并放到请求报文的Cookie首部行中

**Session**

Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session 需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一 个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session 依据该Cookie来识别是否为同一用户。

该Cookie为服务器自动生成的，它的maxAge属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。

**sessionStorage**

用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。保存在浏览器端

**localStorage**

用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。保存在浏览器端

------

### 补码与位运算

[java位运算](https://blog.csdn.net/javazejian/article/details/51181320)

**原码**

原码是一种计算机中对数字的二进制定点表示方法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1，其余位表示数值的大小。

［＋5］=[00000101]（原码）

［ -  5］=[10000101]（原码）

因为第一位是符号位，因此8位二进制的取值范围就是［1111 1111，0111 1111］也就是［-127,127］

**反码**

反码是数值存储的一种，表示方法如下:

- 正数的反码是其本身
- 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

［＋5］=[00000101]（原码）＝ ［00000101］（反码）

［ -  5］=[10000101]（原码）＝ ［11111010］（反码）

**补码**

**在计算机系统中，数值一律用补码来表示和存**储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

［＋5］=[00000101]（原码）＝ ［00000101］（反码）＝［00000101］（补码）

［ -  5］=[10000101]（原码）＝ ［11111010］（反码）＝［11111011］（补码）

**左移**

m<<n的含义:把整数m表示的二进制数左移n位,高位移出n位都舍弃，低位补0.  (此时将会出现正数变成负数的可能)，如下实例：

5<<2 ：把十进制的数值5左移两位,按如下步骤计算，

把5转位16位的二进制机器数：00000000 00000000 00000000 00000101

按左移原理，将二进制数左移两位：00000000 00000000 00000000 00010100

左移后结果为20

5<<29:把十进制的数值5左移29位,按如下步骤计算，

把5转位16位的二进制机器数：00000000 00000000 00000000 00000101

按左移原理，将二进制数左移29位：10100000 00000000 00000000  00000000

左移后高位是1，结果显然是负数

小结：m<<n即在数字没有溢出的前提下，对于正数和负数，左移n位都相当于m乘以2的n次方.

**右移（>>）**

m>>n的含义:把整数m表示的二进制数右移n位

m为正数，高位全部补0；m为负数，高位全部补1,实例如下：

5>>2 ：把十进制的数值5右移两位,按如下步骤计算，

把5转位16位的二进制机器数：00000000 00000000 00000000 00000101

按右移原理，将二进制数左移两位：00000000 00000000 00000000 00000001

右移后结果为1

-5>>2：把十进制的数值-5右移两位,按如下步骤计算，

把-5转位16位的二进制机器数：11111111 11111111 11111111 11111011

按右移原理，将二进制数右移两位：11111111 11111111 11111111 11111110

右移后结果为-2

**无符号右移（>>>）**

m>>>n：整数m表示的二进制右移n位，不论正负数，高位都补0,实例如下：

5>>>2 ：把十进制的数值5右移两位,按如下步骤计算，

把5转位16位的二进制机器数：00000000 00000000 00000000 00000101

按右移原理，将二进制数左移两位：00000000 00000000 00000000 00000001

右移后结果为1

-5>>>2：把十进制的数值-5右移两位,按如下步骤计算，

把-5转位16位的二进制机器数：11111111 11111111 11111111 11111011

按右移原理，将二进制数右移两位：00111111 11111111 11111111 11111110

右移后结果为正数，计算得知为1073741822

**按位非操作（～），单目运算符**

~ 按位取反操作符，对每个二进制位的内容求反，即1变成0，0变成1实例如下

把-5转位16位的二进制机器数：11111111 11111111 11111111 11111011

～(-5) 取反结果：00000000 00000000 00000000 00000100 

转为十进制，结果为4

**按位与操作（&），双目运算符**

& 位与操作符，对应的二进制位进行与操作，两个都为1才为1，其他情况均为0，原理如下:

1&0=0

0&0=0

1&1=1

0&1=0

实例：－5 & 4

-5的二进制形式为： 11111111 11111111 11111111 11111011

 4的二进制形式为：  00000000 00000000 00000000 00000100

——————————————————————————————

逻辑与运算结果：     00000000 00000000 00000000 00000000

最终结果为0。

**按位或操作（｜），双目运算符**

| 位或操作符，对应的二进制位进行或操作，两个都为0才为0，其他情况均为1，原理如下：

1|0=1

0|0=0

1|1=1

0|1=1

实例：-5 ｜ 4

 -5的二进制形式为：11111111 11111111 11111111 11111011

  4的二进制形式为：00000000 00000000 00000000 00000100

————————————————————————————

逻辑或运算结果：    11111111 11111111 11111111 11111111

最终结果为-1。

**按位异或操作（ ^ ），双目运算符**

^ 异或操作符，相同位值为0 否则为1，原理如下：

1^1=0

1^0=1

0^1=1

0^0=0

实例：-5 ^  4

 -5的二进制形式为：11111111 11111111 11111111 11111011

  4的二进制形式为：00000000 00000000 00000000 00000100

————————————————————————————

逻辑异或运算结果：    11111111 11111111 11111111 11111111

最终结果为-1。

其实利用逻辑异或操作有个作用就是可以比较两个数值是否相等，即利用1^1=0,0^0=0的原理，如5^5==0。

------

### SpringAOP

AOP常用的实现方式有两种，

1、采用声明的方式来实现（基于XML），

2、是采用注解的方式来实现（基于AspectJ）。

Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。

**CGLIB**

CGLib动态代理是代理类去继承目标类，然后重写目标类的方法，这样也可以保证代理类拥有目标类的同名方法

代理类去继承目标类，每次调用代理类的方法都会被方法拦截器拦截，在拦截器中才是调用目标类的该方法的逻辑

![img](%E7%9F%A5%E8%AF%86%E7%82%B9.assets/1368608-20190601212347256-869513516.png)

当我们去调用方法一的时候，在代理类中会先判断是否实现了方法拦截的接口，没实现的话直接调用目标类的方法一；如果实现了那就会被方法拦截器拦截，在方法拦截器中会对目标类中所有的方法建立索引，其实大概就是将每个方法的引用保存在数组中，我们就可以根据数组的下标直接调用方法，而不是用反射；索引建立完成之后，方法拦截器内部就会调用invoke方法（这个方法在生成的FastClass中实现），在invoke方法内就是调用CGLIB$方法一$这种方法，也就是调用对应的目标类的方法一；

一般我们要添加自己的逻辑就是在方法拦截器那里。。。。

<img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/1368608-20190602215701685-1483535597.png" alt="img" style="zoom:80%;" />

**JDKProxy**

<img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/1368608-20190528232052512-21443746.png" alt="img" style="zoom:80%;" />

生成一个代理类，代理类通过反射调用被代理类的方法，实现方法增强

------

### Spring事务注解是怎么实现的

方法上面加了@Transactional就会被TransactionInterceptor事务拦截器拦截

拦截器里面都会重写invoke（）方法，思考事务拦截器这里是怎么增强的？

1. 方法开启之前开启事务
2. 如果方法出现异常，加个try catch 让事务回滚。
3. 方法执行结束之后关闭事务

```java
protected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation)
      throws Throwable {

   // If the transaction attribute is null, the method is non-transactional.
   // 解析Transaction注解上的相关属性（隔离级别、传播属性）
   final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);
    // 解析完之后拿事务管理器
   final PlatformTransactionManager tm = determineTransactionManager(txAttr);
    //获取方法上面的一些连接点
   final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);

   if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
      // Standard transaction demarcation with getTransaction and commit/rollback calls.

      //开启事务，并把自动提交关闭
      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
      Object retVal = null;
      try {
         // This is an around advice: Invoke the next interceptor in the chain.
         // This will normally result in a target object being invoked.
         retVal = invocation.proceedWithInvocation();   //执行方法本身进行数据库操作
      }
      catch (Throwable ex) {
         // target invocation exception
         completeTransactionAfterThrowing(txInfo, ex);    //如果出现异常之后要回归 Rollback之后源码会展出。
         throw ex;
      }
      finally {
         cleanupTransactionInfo(txInfo);
      }
      commitTransactionAfterReturning(txInfo);   //没有异常提交事务
      return retVal;
   }
```

基本跟我们预期一致。**这就是整个spring AOP进行增强的过程。**

------

### 如何避免表单重复提交

#### **客户端方案**

**禁掉提交按钮。**

表单提交后使用Javascript使提交按钮disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把Javascript给禁止掉，这种方法就无效了。

**使用Post/Redirect/Get模式**

在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。
这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。

**使用Cookie处理**

使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单，如果客户端禁止了Cookie，该方法将不起任何作用，这点请注意。

#### 服务端方案

**在session中存放一个特殊标志**

在服务器端生成一个唯一的标识符，并将其存入session，同时将之写入表单的隐藏字段中，然后将表单页面发给浏览器。用户录入信息后点击提交。在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除；不相等说明是重复提交，就不再处理。这使你的web应用有了更高级的XSRF保护。

**使用header函数转向**

当用户提交表单，服务器端处理后立即转向其他的页面。这样，即使用户使用刷新键，也不会导致表单的重复提交，因为已经转向新的页面，而这个页面脚本已经不理会任何提交的数据了。

**在数据库里添加约束**

在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。

------

### **mybatis中的#和$的区别**

#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by "111", 如果传入的值是id，则解析成的sql为order by "id".

$将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.

#方式能够很大程度防止sql注入。　

$方式无法防止Sql注入。

$方式一般用于传入数据库对象，例如传入表名.　

MyBatis排序时使用order by 动态参数时需要注意，用$而不是#

------

### union all和union的区别

如果需要将多个select语句的结果作为一个整体显示出来，我们就需要用到union 或union all关键字。

union (或称为联合)的作用是将多个结果合并在一起显示出来。

union 去重且排序（取唯一值，记录没有重复）
union all 不去重不排序（直接连接，取到得是所有值，记录可能有重复）

------