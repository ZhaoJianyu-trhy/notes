# 深入理解JAVA虚拟机——笔记

------



## JAVA内存区域

### <img src="D:\深入理解JAVA虚拟机笔记图片\运行时数据区.png" alt="运行时数据区" style="zoom:67%;" />

#### 1.程序计数器

​	是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在JAVA虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。线程私有，没用任何异常，随线程而生，随线程而灭

####  2.JAVA虚拟机栈

​	虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。线程私有，生命周期与线程相同，StackOverflowError，OutOfMemoryError异常,随线程而生，随线程而灭

#### 3.本地方法栈

​	本地方法栈与虚拟机栈所发挥的作用是十分相似的，其区别只是虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。HotSpot虚拟机直接就把本地方法栈和虚拟机栈合二为一。StackOverflowError，OutOfMemoryError异常,随线程而生，随线程而灭

#### 4.Java堆

​	Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里几乎（一些新兴技术已经导致一些微妙的变化悄然发生）所有的对象实例都在这里分配内存。

​	Java堆是垃圾收集器管理的内存区域，也叫做GC堆。参数-Xmx和-Xms就与java堆有关。OutOfMemoryError异常

-Xms:初始堆大小
-Xmx:最大堆大小
-Xmn:新生代大小	老年代大小：-Xmx - -Mmn
-XX:NewRatio:设置新生代和老年代的比值。如：为3，表示年轻代与老年代比值为1：3
-XX:SurvivorRatio:新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden：Survivor=3：2，一个Survivor区占整个新生代的1/5  
-XX:MaxTenuringThreshold:设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代
-XX:PermSize、-XX:MaxPermSize:分别设置永久代最小大小与最大大小（Java8以前）
-XX:MetaspaceSize、-XX:MaxMetaspaceSize:分别设置元空间最小大小与最大大小（Java8以后）

#### 5.方法区

与堆一样，各个线程共享的内存区域。它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。这个区域甚至可以不实现垃圾收集，OutOfMemoryError异常

#### 6.运行时常量池

​	是方法区的一部分.Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池具有动态性，运行期间也可以将新的常量放入池中，OutOfMemoryError异常

例如代码 String str = "123";

#### 7 内存溢出

##### 1.内存溢出和内存泄漏

​	内存溢出 OutOfMemory，指程序在申请内存时，没有足够的内存空间供其使用。

​	内存泄漏 Memory Leak，指程序在申请内存后，无法释放已申请的内存空间，内存泄漏最终导致内存溢出。

##### 2.堆溢出

​	堆用于存储对象实例，只要不断创建对象并保证GC Roots到对象有可达路径避免垃圾收集，随着对象数量的增加，总容量触及最大堆容量后就会OOM，例如在while死循环中一直new创建实例。

​	堆OOM是实际应用中最常见的OOM，处理方法是通过内存映像分析工具对Dump出的堆转储快照分析，确认内存中导致OOM的对象是否有必要，分清到底是内存泄漏还是内存溢出。

​	如果是内存泄漏，通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots关联才导致无法回收，一般可以准确定位到产生内存泄漏代码的具体位置。

​	如果不是内存泄漏，即内存中对象都必须存活，应当检查JVM堆参数，与机器内存相比是否还有上调空间。再从代码检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

##### 3.栈溢出

​	由于HotSpot不区分虚拟机栈和本地方法栈，设置本地方法栈大小的参数没有意义，栈容量只能由-Xss参数来设定，存在两种异常：

​	StackOverFlowError：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError，例如一个递归方法不断调用自己。该异常有明确错误堆栈可供分析，容易定位到问题所在。

​	OutOfMemoryError：如果JVM栈可以动态扩展，当扩展无法申请到足够内存时会抛出OutOfMemoryError。HotSpot不支持虚拟机动态扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OOM，否则在线程运行时是不会因为扩展而导致溢出的。

### HotSpot虚拟机对象探秘

#### 1.对象的创建

​	**1.**一般情况下创建一个对象，java中使用new关键字。当java虚拟机遇到一条字节码new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那么就先执行相应的类加载过程。

​	**2.**类加载检查通过后，虚拟机将为新生对象分配内存。根据java堆是否规整，或者所采用的垃圾收集器是否具备空间压缩整理能力，有两种内存分配方式：1.指针碰撞、2.空闲列表。

​	内存分配之中可能会涉及到并发的问题，有两种解决方案。

​		**1.**对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；

​		**2.**把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，成为本地线程分配缓冲（Thread Local Allocation Buff，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

​	**3**.内存分配完成之后，虚拟机进行初始化操作。虚拟机将分配到的内存空间（不包括对象头）都初始化为0值，使用了TLAB的话，这一项工作可以提前至TLAB分配时进行。这部操作保证了对象的实例字段在java代码中可以不赋初值就直接使用，让程序能够访问到这些字段的数据类型对应的零值。

​	4.java虚拟机对对象进行一些必要的设置，例如这个对象是哪个类的实例、对象的GC分代年龄、如何才能找到类的元数据信息，对象的哈希码等等。

​	以上的步骤，如果从虚拟机的角度来看，一个新的对象产生了，但是从java程序的角度来看，对象的创建才刚刚开始——构造函数，接下来需要执行Class文件中的<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

#### 2.对象的内存布局

​	在hotspot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据、对齐填充

​	1.对象头：包括两类信息

​		1.存储对象自身的运行时数据，如哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

​		2.类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。

​	2.实例数据：对象真正存储的有效信息，即我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。

​	3.对齐填充：这并不是必然存在的，也没有特别的含义，仅仅起占位符的作用。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分被设计成了8字节的倍数，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

------

## 垃圾收集器与内存分配策略

垃圾收集需要思考的三个问题

#### 1.哪些内存需要回收？

​	Java内存运行时区域中的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。

​	Java堆和方法区这两个区域有很显著的不确定性。垃圾收集器所关注的正是这部分内存该如何管理。

#### 2.什么时候回收？

​	在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，首先要判断这些对象哪些还“存活”着，哪些已经“死去”（不可能再被任何途径使用的对象）。

##### 	1.Java虚拟机并不是通过引用计数算法来判断对象是否存活的。

##### 	2.可达性分析算法

​	当前主流的商用程序语言（Java、C#）都是通过可达性分析算法来判定对象是否存活的。

​	基本思路：以一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走的路径称为“引用链”，如果某个对象到GC Roots没用任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

<img src="D:\深入理解JAVA虚拟机笔记图片\可达性分析.png" style="zoom:67%;" />

​	Java技术体系里，固定作为GC Roots的对象如下：

​		1.在虚拟机栈（栈帧的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

​		2.在方法区中类静态属性引用的对象，譬如Java类的引用类静态变量。

​		3.在方法区中常量引用的对象，譬如字符串常量池里的引用。

​		4.在本地方法栈JNI（即通常说的Native方法）引用的对象。

​		5.Java虚拟机内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象（比如NullPointException，OutOfMemoryError）等，还有系统类加载器。

​		6.所有被同步锁（synchronized关键字）持有的对象。

​		7.反映Java虚拟机内部情况的JMXBean，JVMTI中注册的回调、本地代码缓存等。

​		除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”加入，共同构成GC Roots集合。

##### 3.再谈引用

​	JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种。这4种引用强度依次逐渐减弱。

​	强引用：最传统的“引用”定义，类似于“Object obj = new Object()”这种引用关系。无论何种情况下，只要强引用关系存在，垃圾收集器就不会回收被引用的对象。

​	软引用：软引用描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后提供了SoftReference类来实现软引用。

​	弱引用：也是描述那些非必需对象，但它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。JDK1.2之后提供了WeakReference类来实现弱引用。

​	虚引用：也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供PhantomReference来实现虚引用。

##### 4 最终判断，生存还是死亡 finalize()判定

​	在前述的可达性分析中判断为不可达的对象，也不是立即宣告死亡了的。一个对象“真正”死亡，至少要经历两次标记：如果可达性分析中该对象没有与GC Roots相连的引用链，第一次标记；随后进行一次筛选，筛选出需要执行finalize()方法的对象（如果finalize()方法没有被覆盖，或者该方法已经被调用过了，则不执行）。如果该对象需要执行finalize()方法，该对象会进入一个名为F-Queue的队列，稍后会有一条由虚拟机自动创建，低调度优先级的Finalizer线程去执行这些对象的finalize()方法。如果finalize()方法中该对象重新与引用链上任何一个对象建立了关联，则在第二次标记时将该对象移出“即将回收”的集合。如果对象此时没有逃脱，就真正被回收。

#### 3.垃圾收集算法

​	介绍的所有算法都是追踪式垃圾收集的范畴。

##### 	1.分代收集理论

​		三个分代假说：

​			1.弱分代假说：绝大多数对象都是朝生夕灭的。

​			2.强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

​			3.跨代引用假说：跨代引用相对于同代引用来说仅占极少数。可以在新生代上建立一个全局的数据结构（记忆集，Remember Set），这个结构把老年代划分为若干小块，标识出老年代的哪一块内存存在跨代引用。当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Rroots中扫描。虽然这种方法需要在对象改变引用关系时，维护记录数据的正确性，但比起收集时扫描整个老年代来说仍然是划算的。

##### 	2.标记清除算法

​		算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收所有被标记的对象，也可以反过来标记存活的对象，统一回收所有未被标记的对象。标记过程就是判定对象是否属于垃圾的过程。

​		两个主要缺点：

​			1.执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低；

​			2.内存空间碎片化，标记、清除之后会产生大量的不连续内存碎片。

<img src="D:\深入理解JAVA虚拟机笔记图片\标记清除算法.png" style="zoom:67%;" />

##### 3.标记复制算法

​	简称为复制算法，是为了解决标记-清除算法面对大量可回收对象时执行效率低问题提出的。采用了“半区复制”的策略。

<img src="D:\深入理解JAVA虚拟机笔记图片\标记复制算法.png" style="zoom:67%;" />

​	“Appel”式回收：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和使用的Survivor空间。HotSpot虚拟机默认Eden和Survivor大小比例是8：1，即每次新生代中可用内存空间为整个新生代容量的90%，只有一个Survivor空间即10%的新生代会被“浪费”。

​	"Apple"式回收还有一个“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象，需要依赖其他内存区域（实际上大多就是老年代）进行分配担保。即如果另一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便通过担保分配机制直接进入老年代，对虚拟机来说也是安全的。（这些对象是完整的，还是另一块Survivor空间装满之后多余的？）

##### 4.标记-整理算法

​	老年代一般不能用标记-复制算法。针对老年代对象的存亡特征，提出了一种移动式的标记-整理算法。其标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

<img src="D:\深入理解JAVA虚拟机笔记图片\标记整理算法.png" style="zoom:67%;" />

​	缺点：老年代中有大量的存活对象，移动存活对象并更新所有引用这些对象的地方是一种极为负重的操作，并且移动操作必须全程暂停用户运用程序，即“Stop The World”。

​	但是不移动则会使内存分配更加复杂。HotSpot虚拟机中关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的；而关注延迟的CMS收集器则是基于标记-清除算法的。

​	此外还可采用一种“和稀泥”式的方案：让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种方法。

#### 3.4 HotSpot的算法细节实现

##### 3.4.1 根节点枚举

​	固定可作为GC Roots的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中。迄今为止，所有收集器在根节点枚举这一步骤时都必须暂停用户线程，面临“Stop The World”的困扰。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行，这是导致垃圾收集过程必须停顿所有用户线程的一个重要原因，即使是号称停顿时间可控，或者几乎不会发生停顿的CMS,G1,ZGC等收集器，根节点枚举时也是必须停顿的。

​	目前主流的Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来之后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置。HotSpot使用了一组称为OopMap的数据结构来达到这个目的：一旦类加载动作完成，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用，这样收集器在扫描时就可以直接得知这些信息了。

##### 3.4.2 安全点

​	HotSpot没有为每条指令都生成OopMap，只是在“特定的位置“记录了这些信息，这些位置称为“安全点”。有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行达到安全点后才能够暂停。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的。“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于序列复用，所以只有具有这些功能的指令才会产生安全点。

​	还有一个问题需要考虑的是：如何在垃圾收集时让所有的线程(不包括JNI调用的线程)都跑到最近的安全点，然后停顿下来。有两种方案，如下：

​		1.抢先式中断(Preemptive Suspension)：不需要线程的执行代码主动配合，在垃圾收集发生时，系统首先把所有用户线程		全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全		点上。几乎没有虚拟机采用这种方式。

​		2.主动式中断(Voluntary Suspension)：当垃圾收集需要中断线程时，不直接对线程操作，仅仅简单设置一个标志位，各个		线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询		标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否		即将要发生垃圾收集，避免没有足够内存分配新对象。HotSpot使用内存保护陷阱的方式，将轮询操作精简至只有一条汇		编指令的程度，使轮询操作足够高效。

##### 3.4.3 安全区域

​	安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是程序不执行的时候，即用户线程处于Sleep状态或Blocked状态，这时线程无法响应虚拟机的中断请求，不能再走到安全点的地方去中断挂起自己。对于这种情况，引入了“安全区域”来解决。

​	安全区域指能够确保在某一段代码片段之中，引用关系不会发生变化，因此在这个区域中任何地方开始垃圾收集都是安全的，也可以把安全区域看作被扩展拉伸了的安全点。

​	当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，当这段时间里虚拟机要发起垃圾收集时可以不管这些已声明自己在安全区域内的线程。当线程要离开区域时，它要检查虚拟机是否已经完成了根节点枚举(或其他需要暂停用户线程的阶段)，如果完成了，那线程就当作没事发生，继续执行，否则就一直等待，直到收到可以离开安全区域的信号为止。

##### 3.4.4 记忆集与卡表

​	记忆集是一种抽象的概念，卡表是记忆集的一种实现，类似于Map和HashMap的关系。记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。HotSpot虚拟机中卡表是一个字节数组(CARD_TABLE)，其中每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为“卡页”(Card Page)。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-10 160610.png" style="zoom:50%;" />

​	一个卡页的内存中通常包含不止一个对象，只要卡页内有一个(或更多)对象的字段存在着跨代指针，那就将对应卡表的数组元素标识1，称这个元素变脏(dirty)，没有则标识0。垃圾收集时，筛选出卡表中变脏的元素即可，就能得到哪些卡页内存块中包含跨代指针，加入GC Roots一并扫描。

##### 3.4.5 写屏障

​	在HotSpot虚拟机里通过写屏障(Write Barrier)技术维护卡表状态。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形(Around)通知，供程序执行额外的动作。在复制前的部分的写屏障叫做写前屏障(Pre-Write Barrier)，在赋值后的则叫做写后屏障(Post-Write Barrier)。

​	应用写屏障后，虚拟机会为所有的赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表的操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过比Minor GC时扫描整个老年代的代价还是低得多。

​	写屏障为了避免伪共享问题(缓存行)，可以使用的解决方案是：不使用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记时才将其标记为变脏。

​	运用写屏障后，可以在对象赋值的那一刻去更新维护卡表。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-14 181720.png" style="zoom:100%;" />

#### 3.5 经典垃圾收集器

<img src="D:\深入理解JAVA虚拟机笔记图片\经典垃圾收集器.png" style="zoom:67%;" />

​	若两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，表示它是属于新生代收集器或老年代收集器。

##### 3.5.1 Serial收集器

​	Serial收集器是最基础，历史最悠久的收集器。这个收集器是一个单线程工作的收集器，“单线程”强调的是它在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

<img src="D:\深入理解JAVA虚拟机笔记图片\Serial收集器.png" style="zoom:67%;" />

​	事实上，它仍然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方——简单高效，对于内存资源受限的环境，它是所有收集器里额外内存消耗（为保证垃圾收集能够顺利高效地进行而存储地额外信息）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

##### 3.5.2 ParNew收集器

​	ParNew收集器实质上是Serial收集器的多线程并行版本。其工作过程如图所示：

<img src="D:\深入理解JAVA虚拟机笔记图片\ParNew收集器.png" style="zoom:67%;" />

​	自JDK9开始，ParNew合并入CMS，成为它专门处理新生代的组成部分。ParNew可以说是HotSpot虚拟机中第一款推出历史舞台的垃圾收集器。

​	ParNew收集器在单核心处理器的环境中绝对不会有比Seriral收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程(Hyper-Threading)技术实现的伪双核处理器环境中都不能百分百保证超越Seriral收集器。

<img src="D:\深入理解JAVA虚拟机笔记图片\垃圾收集器的并行，并发.png" style="zoom:80%;" />

##### 3.5.3 Parallel Scavenge收集

​	Parallel Scavenge收集器也是一款新生代收集器，同样也是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，从表面上看Parallel Scavenge与ParNew非常相似。

​	Parallel Scavenge收集器的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。

<img src="D:\深入理解JAVA虚拟机笔记图片\吞吐量.png" style="zoom:67%;" />

​	由于与吞吐量关系密切，Parallel Scavenge收集器又称“吞吐量优先收集器”。Parallel Scavenge收集器还具有自适应调节策略,这也是它区别于ParNew收集器的一个重要特性。

##### 3.5.4 Serial Old收集器

​	Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，使用标记-整理算法。其工作过程如图所示：

<img src="D:\深入理解JAVA虚拟机笔记图片\Serial Old收集器.png" style="zoom:67%;" />

##### 3.5.5 Parallel Old收集器

​	Parallel Old收集器是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优秀考虑Parallel Scavenge加Parallel Old收集器这个组合。Parallel Old收集器的工作过程如图：

<img src="D:\深入理解JAVA虚拟机笔记图片\Parallel Old收集器.png" style="zoom:67%;" />

##### 3.5.6 CMS收集器

​	CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。是基于标记-清除算法实现的，运作过程分为四个步骤：

​		1.初始标记

​		2.并发标记

​		3.重新标记

​		4.并发清除

​	初始标记、重新标记这两个步骤仍然需要“stop the world”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；重新标记是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；并发清除，删掉标记阶段判断的已经死亡的对象，由于不需要移动对象，所以是与用户线程同时并发的。

​	在整个过程中耗时时间最长的并发标记和并发清除阶段，垃圾收集器线程都可以与用户线程一起工作，所以从总体上讲，CMS收集器的内存回收过程是与用户线程一起并发执行的。

<img src="D:\深入理解JAVA虚拟机笔记图片\CMS收集器.png" style="zoom:67%;" />

​	CMS的主要优点：并发收集，低停顿

​	三个明显的缺点：

​		1.CMS收集器对处理器资源非常敏感

​		2.CMS收集器无法处理“浮动垃圾”，有可能导致Full GC的产生。

​		3.基于标记-清理算法，意味着收集结束时会有大量空间碎片产生。

##### 3.5.7 Garbage First 收集器

​	Garbage First收集器开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。G1是一款主要面向服务端应用的的垃圾收集器。作为CMS收集器的替代者和继承人，设计者们提出了“停顿时间模型”——能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。

​	G1可以面向堆内存任何部分来组成回收集(Collection Set)进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

​	G1开创了基于**Region**的堆内存布局。虽然G1也是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。

​	Region中还有一类特殊的Humongous区域，专门存储大对象。G1认为只要大小超过了1个Region容量的一半的对象即可判定为大对象。对于大小超过了整个Region容量的超大对象，存放在N个连续的Humongous Region之中。G1大部分行为把Humongous Region作为老年代的一部分来看待。

​	G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间以及回收所需时间的经验值，然后再后台维护一个优先级列表，优先处理回收价值收益最大的那些Region,这也是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-13 154442.png" style="zoom:50%;" />

​	G1的记忆集在存储结构的本事上是一中哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号，这是一种双向的卡表结构(卡表是“我指向谁”，这种结构还记录了“谁指向我”)。

​	在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照(STAB)算法来实现的。G1为每个Region设计了两个名为TAMS(Top at Mark Start)的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。如果内存回收的速度赶不上内存分配二等速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。

​	G1收集器的运作过程大致分为以下四个步骤：

​		1.初始标记

​		2.并发标记

​		3.最终标记

​		4.筛选回收

​	除了并发标记外，其余阶段都需要完全暂停用户线程。通常将期望停顿时间设置为一两百毫秒或者两三百毫秒比较合理。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-13 182428.png" style="zoom:67%;" />

​	与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部(两个Region之间)看又是基于“标记-复制”算法实现。G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。

​	CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行同样的卡表维护操作外，为了实现原始快照搜索算法(SATB),，还使用了写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗。

##### 3.6 低延迟垃圾收集器

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-14 184203.png" style="zoom:67%;" />

​	浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的。最后两款收集器，几乎整个工作过程全部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿时间基本上是固定的，与堆的容量、堆中对象的数量没有正比例关系。

###### 3.6.1 Shenandoah收集器	

​	目标是实现一种能在任何堆内存大小下都可以把垃圾收集器的停顿时间限制在十毫秒以内，意味着，Shenandoah不仅要进行并发的垃圾标记，还要并发地进行对象清理后的整理动作。

​	相比于G1的特点：

​		1.支持并发的整理算法；

​		2.默认不使用分代收集，即不会有专门的新生代Region或者老年代Region的存在；

​		3.摒弃了记忆集，改用名为“连接矩阵”的全局数据结构来记录跨Region的引用关系，连接矩阵可以理解是一张二维表格，			如果RegionN有对象指向RegionM，就在表格的N行M列中打上一个标记，通过表格就可以得出哪些Region之间产生了			跨代引用。即降低了处理跨代指代指针时的记忆集维护消耗，也降低了伪共享问题发生概率。

​	工作过程大致分为九个阶段：

​		1.初始标记(Initial Marking)：标记与GC Roots直接关联的对象，仍然需要“Stop The World”。

​		2.**并发标记**(Concurrent Marking)：遍历对象图，标记出全部可达对象，与用户线程并发。

​		3.最终标记(Final Marking)：处理剩余的SATB扫描，统计回收价值最高的Region，构成回收集。会有短暂的停顿。

​		4.并发清理(Concurrent Cleanup)：清理那些整个区域连一个存活对象都没有找到的Region(Immediate Garbage Region)

​		5.**并发回收**(Concurrent Evacuation)：Shenandoah通过读屏障和被称为“Brooks Pointers”的转发指针来复制存活对象。

​		6.初始引用更新(Initial Update Reference)：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到新			地址。其实并没有具体的处理，只是设立一个集合点。

​		7.**并发引用更新**(Concurrent Update Reference)：真正开始进行引用更新操作，与用户线程并发。

​		8.最终引用更新(Final Update Reference)：修正GC Roots中的引用。

​		9.并发清理(Concurrent Cleanup)：并发清理内存空间。

​	对象移动与用户程序并发的一种解决方案——转发指针(Forwarding Pointer)

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-15 192837.png" style="zoom:67%;" />

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-15 192902.png" style="zoom:67%;" />

###### 3.6.2 ZGC收集器

​	ZGC的目标与Shenandoah相似，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。

​	定义：ZGC收集器是一款基于Region内存布局的，(暂时)不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

​	ZGC也采用了基于Region的堆内存布局，但是ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-19 173516.png" style="zoom:67%;" />

​	Shenandoah使用转发指针和读屏障来实现并发整理，ZGC同样用到了读屏障，但是有所区别——染色指针技术，它直接把标记信息记在引用对象的指针上，这时与其说可达性分析是遍历对象图来标记对象，还不如说是遍历“引用图”来标记“引用”了。

​	使用染色指针的优点：

​		1.染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能被释放和重用掉。

​		2.染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量。

​		3.染色指针可以作为一种可扩展的存储结构来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性 			能。	

​	ZGC的运作过程可分为如下四个大阶段，四个阶段都是可以并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-19 175034.png" style="zoom:67%;" />

​	1.并发标记(Concurrent Mark)：并发标记是遍历对象图做可达性分析的阶段，前后也要经过初始标记、最终标记的短暂停顿。ZGC的标记是在指针上而不是在对象上进行的。

​	2.并发预备重分配(Concurrent Prepare for Relocate)：统计出需要清理哪些Region，并将这些Region组成重分配集。ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，并不是说回收行为是阵对这个集合的。

​	3.并发充分配(Concurrent Relocate)：核心阶段。把重分配集中的存活对象复制到新的Region上，为充分配集中的每个Region维护一个转发表(Forward Table)，记录从旧对象到新对象的转向关系。有指针“自愈”能力。

​	4.并发重映射(Concurrent Remap)：修正整个堆中指向重分配集旧对象的所有引用。但并不迫切，这个阶段被放置在了下一次垃圾收集循环中的并发标记阶段里去完成，这样合并节省了一次遍历对象图的开销。

------

### 类文件结构

​	代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

​	<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-20 181722.png" style="zoom:67%;" />

#### 6.3 Class类文件的结构

​	Class文件是一组以8个字节为基础单位的二进制流。Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数、表。

​	无符号数：属于基本的数据类型、u1，u2，u4，u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

​	表是由多个无符号数或者其他表作为数据项构成的复合数据类型，表名都以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表。如图所示：

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-20 182340.png" style="zoom:67%;" />

​	无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干连续的数据项的形式，称这一系列连续的某一类型的数据为某一类型的“集合”。

##### 6.3.1 魔数与Class文件的版本

​	头4个字节被称为魔数，唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。Class文件的魔数为“0xCAFEBABE”。

​	接下来4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号(Minor Version)，第7个第8个字节是主版本号(Major Version)。

##### 6.3.2 常量池

​	常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。

​	因为常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。

​	常量池中主要存放两大类常量：字面量(Literal)和符号引用(Symbolic References)。字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等；而符号引用则属于编译原理方面的概念，主要包括下面几类常量：

​		1.被模块导出或开放的包(Package)

​		2.类和接口的全限定名(Fully Qualified Name)

​		3.字段的名称和描述符(Descriptor)

​		4.方法的名称和描述符

​		5.方法句柄和方法类型(Method Handle、Method Type、Invoke Dynamic)

​		6.动态调用点和动态常量(Dynamically-Coomputed Call Site、Dynamiclly-Computed Constant)

​	常量池每一项常量都是一个表，截止JDK13，常量表中分别有17种不同类型的常量。这17类表都有一个共同的特点，表结构起始的第一位是u1类型的标志位(tag)，代表着当前常量属于哪种常量类型。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-21 151222.png" style="zoom:67%;" />

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-21 173908.png" style="zoom:67%;" />

![](D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-21 173950.png)

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-21 174914.png" style="zoom:67%;" />

##### 6.3.3 访问标志

​	常量池后面的2个字节代表访问标志(access_flags)，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等.

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-21 175527.png" style="zoom:67%;" />

##### 6.3.4 类索引、父类索引与接口索引集合

​	类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。

​	类索引、父类索引和接口索引集合都按顺序排列在访问标志之后。类索引和父类索引各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到CONSTANT_Utf8_info类型的常量中的全限定名字符串。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-22 200140.png" style="zoom:67%;" />

​	对于接口索引集合，入口的第一项u2类型的数据为接口计数器(interfaces_count)，表示索引表的容量。若该类没有实现任何接口，则该计数器为0，后面接口的索引表不再占用任何字节。

##### 6.3.5 字段表集合

​	字段表(field_info)用于描述接口或类中声明的变量。“字段”包括类级变量以及实例级变量，但不包括方法内部的局部变量。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-23 154941.png" style="zoom:67%;" />

​	字段修饰符放在access_flags项目中，是一个u2的数据类型，其中可以设置的标志位和含义如下表所示：

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-23 155059.png" style="zoom:67%;" />

​	access_flags标志后面是两项索引值：name_index和descriptor_index，都是对常量池的引用，分别代表字段的简单名称、字段和方法的描述符。描述符的作用是描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。如下表：

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-23 180638.png" style="zoom:67%;" />

​	字段表所包含的固定数据项目到descriptor_index就截止了。但是之后会跟随一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。关于attribute_info，后文会介绍到。

​	字段表集合不会列出从父类或者父接口中继承而来的字段。Java中字段是不能重载的，但在Class文件中，只要两个字段描述符不是完全相同，字段重名就合法。

##### 6.3.6 方法表集合

​	方法表的结构如同字段表一样，依次包括访问标志(access_flags)、名称索引(name_index)、描述符索引(descriptor_index)、属性表集合(attributes)，如下表所示。这些数据项目的含义与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有区别。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-23 181730.png" style="zoom:67%;" />

​	方法里的Java代码，经过Javac编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。

​	Java中重载一个方法，必须要有不同的特征签名(不包含返回值)，但是Class文件格式中，如果两个方法有相同的名称和特征签名，但返回值不同，也是合法共存于同一个Class文件中的。

##### 6.3.7 属性表集合

​	Class文件、字段表、方法表可以携带自己的属性表集合，以描述某些场景专有的信息。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-25 172032.png" style="zoom:80%;" />

![](D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-25 172221.png)

​	对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度去说明属性值所占用的位数即可。一个符合规则的属性表应该满足如下结构：

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-25 172802.png" style="zoom:67%;" />

###### 1. Code属性

​	Java程序方法体里面的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或抽象类中的方法就不存在。如果有，Code属性的结构如下所示：

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-25 183722.png" style="zoom:67%;" />

### 第七章 虚拟机类加载机制

​	Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程叫做虚拟机的类加载机制。

#### 7.2 类加载的时机

​	一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载(Loading)、验证(Vertification)、准备(Preparation)、解析(Resolution)、初始化(Initialzation)、使用(Using)和卸载(Unloading)七个阶段。其中验证、准备、解析三个部分成为连接(Linking)。顺序如图所示：

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-27 093834.png" style="zoom:67%;" />

​	加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始。

#### 7.3 类加载的过程

##### 7.3.1 加载

​	在加载阶段，Java虚拟机需要完成以下三件事情：

​		1.通过一个类的全限定名来获取定义此类的二进制字节流。

​		2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

​		3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

​	加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了。加载阶段与连接阶段的部分动作是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。

##### 7.3.2 验证

​	验证的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

​	验证阶段可以分为四个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

###### 1. 文件格式验证

​	第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。该阶段的验证是基于二进制字节流进行的，只有通过了这个杰顿的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中存储，所以后三个阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。

###### 2.元数据验证

​	第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。

###### 3.字节码验证

​	主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。这阶段对类的方法体(Class文件中的Code属性)进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。

​	如果一个方法体通过了字节码验证，也不能保证它一定就是安全的。不可能用程序来准确判断一段程序是否存在Bug。

###### 4.符号引用验证

​	这个校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配校验，通俗说就是，该类是否缺少或被禁止访问它依赖的某些外部类、方法、字段等资源。

​	主要目的是确保解析行为能正常执行。

##### 7.3.3 准备

​	准备阶段是正式为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始值的阶段。

​	有两点需要特别说明：

​		1.这时进行的内存分配仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随对象一起分配在Java堆中。

​		2.初始值“通常情况”是数据类型的零值，例如

​	

```java
	public static int value = 123;
```

​	变量value在准备阶段过后的初始值是0而不是123，因为这是没有执行任何Java方法，而123赋值要到类的初始化阶段。

​	下图是基本类型的零值：

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-27 110332.png" style="zoom:67%;" />

​	如果类字段的字段属性表中存在ConstantValue属性，那么准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。例如

​	

```java
public static final int value = 123
```

​	编译时Javac会为value生成ConstantValue属性，准备阶段虚拟机会根据ConstantValue的设置把value赋值为123.

##### 7.3.4 解析

​	解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。

​	符号引用(Symbolic References)：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定是已加载到虚拟机内存当中的内容。

​	直接引用(Direct References)：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的；如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

​	解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。

##### 7.3.5 初始化

​	初始化阶段Java虚拟机才真正开始执行类中编写的Java程序代码。

​	准备阶段时，变量已经赋过一次系统要求的初始零值，初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源，初始化阶段就是执行类构造器<clinit>()方法的过程，它时Javac编译器的自动生成物。

#### 7.4 类加载器

​	Java虚拟机设计团队有意把加载阶段中“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现。实现这个动作的代码被称为“类加载器(Class Loader)”。

##### 7.4.1 类与类加载器

​	对于任何一个类，都必须由它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。也就是说，判断两个类是否“相等”，必须来源于同一个Class文件，且被同一个Java虚拟机加载，加载它们的类加载器相同。

##### 7.4.2 双亲委派模型(针对jdk8及之前版本)

​	绝大多数Java程序都会用到以下3个系统提供的类加载器来进行加载：

###### 	1.启动类加载器(引导类加载器)(Bootstrap Class Loader)

​	这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够时别的类库加载到虚拟机的内存中。不能直接被Java程序引用。

###### 	2.扩展类加载器(Extention Class Loader)

​	这个加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。这是一种Java系统类库的扩展机制。可以在程序中直接使用扩展类加载器来加载Class文件。

###### 	3.应用程序类加载器(系统类加载器)(Application Class Loader)

​	这个类加载器由sun.misc.Launcher$AppClassLoader来实现。也称为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库，可以直接在代码中使用这个类加载器。如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。

​	下图所示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型”(Parents Delegation Model)。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-27 190907.png" style="zoom:67%;" />

​	双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去完成加载。

​	优点：Java中的类跟随它的类加载器一起具备了一种带有优先级的层次关系。

###### 7.5.2 模块化下的类加载器

​	jdk9之后由于引入了Java模块化系统(Java Platform Module System, JPMS)，类加载器发生了一些变动。

​	扩展类加载器(Extention Class Loader)被平台类加载器(Platform Class Loader)取代。

​	jdk9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系发生了变动。当平台及应用程序类加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，这也算作是对双亲委派模型的一次“破坏”。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-28 095527.png" style="zoom:60%;" />

### 第八章 虚拟机字节码执行引擎

​	在不同的虚拟机实现中，执行引擎在执行字节码的时候，会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择。但从外观上看，所有Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。本章主要讲解虚拟机的方法调用和字节码的执行。

#### 8.2 运行时栈帧结构

​	Java虚拟机以方法作为最基本的执行单元，栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。

​	每一个方法从调用开始至执行结束的过程，都对应一个栈帧在虚拟机栈里面从入栈到出栈的过程。

​	栈帧中包括局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-28 102926.png" style="zoom:67%;" />

##### 8.2.1 局部变量表(Local Variables Table)

​	局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。

​	当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。

##### 8.2.2 操作数栈(Operand Stack)

​	操作数栈也可成为操作栈，是一个后入先出(LILO)的栈。

​	当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。

​	Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。

##### 8.2.3 动态连接

​	Class文件的常量池中存有大量的符号引用，有一部分会在每一次运行期间转化为直接引用，这部分就成为动态链接。而另一部分会在类加载阶段或者第一次使用的时候被转化为直接引用，这种转化被称为静态解析。

##### 8.2.4 方法返回地址

​	方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。方法异常退出时，返回地址是要通过异常处理表来确定的，栈帧中就一般不会保存这部分信息。

##### 8.2.5 附加信息

​	《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。在讨论概念时，一般会把动态链接、方法返回地址与其他附加信息全部归为一类，称栈帧信息。

#### 8.3 方法调用

​	方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)，没有涉及到方法内部的具体运行过程。一切方法调用在Class文件里存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址(直接引用)。

##### 8.3.1 解析

​	所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会有一部分符号引用转化为直接引用。前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。这类方法的调用被称为解析(Resolution)。例如静态方法，私有方法、实例构造器、父类方法、被finial修饰的方法，统称为“非虚方法”，其他方法被称为“虚方法”。

​	解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。

##### 8.3.2 分派

​	分派是另一种方法调用形式。

###### 1.静态分派(Method Overload Resolution)

​	虚拟机在重载时通过参数的静态类型而不是实际类型作为判断依据。静态类型在编译器可知，所以在编译阶段，Javac编译器能根据参数的静态类型决定使用哪个重载版本。

​	所有依赖静态类型来决定方法执行版本的分派动作，都成为静态分派。静态分派最典型应用表现就是方法重载。静态分派发生在编译阶段。

###### 2.动态分派

​	动态分派与重写(Override)有密切的关联。

​	在运行期根据实际类型确定方法版本的分派过程称为动态分派。动态分派的根源在于虚方法调用指令invokevirtual的执行逻辑。显然，只有虚方法，字段是没有虚的，换言之字段不参与多态。当子类声明了与父类同名的字段时，虽然在字段的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段。哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。

###### 3. 单分派与多分派

​	方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。

​	Java语言目前是静态多分派，动态单分派的语言。

#### 8.5 基于栈的字节码解释执行引擎

​	本节主要探讨虚拟机如何执行方法里面的字节码指令，在概念模型下的Java虚拟机解释执行字节码时，其执行引擎如何工作。

##### 8.5.1 解释执行

​	大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图步骤。图中下面那条分支，是传统编译原理中程序代码到目标机器代码的生成过程；中间那条分支，是解释执行的过程。

<img src="D:\深入理解JAVA虚拟机笔记图片\屏幕截图 2020-10-28 183002.png" style="zoom:67%;" />

​	Java中，Javac编译器完成了程序代码经过此法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部，所以Java程序的编译就是半独立的实现。

##### 8.5.2 基于栈的指令集与基于寄存器的指令集

​	Javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构(Instruction Set Architecture，ISA)，字节码指令流里面的大部分都是零地址指令，依赖于操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的是x86二地址指令集。

​	基于栈的指令集的主要优点是可移植，缺点是执行速度理论上说稍慢(由于指令数量和内存访问的原因)。
